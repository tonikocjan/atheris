\chapter{Uvod}

Razvoj prevajalnikov, ter s tem tudi programskih jezikov, je, po mojem mnenju, izjemno pomembna panoga v računalništvu. Programski jezik je medij, preko katerega komuniciramo z računalnikom. Prevajalniki razvijalcem omogočajo, da se med razvojem programske opreme ne rabijo osredotočati na nizkovojske detajle, ampak se lahko posvetijo reševanju praktičnih problemov. Naloga prevajalnika je, da pretvori človeku berljivo kodo v računalniku razumljivo zaporedje strojnih ukazov. \\
\indent Dandanes lahko za razvoj programske opreme izbiramo med velikim številom programskih jezikov. Trenutno eni izmed najbolj popularnih so, Java, C in C++, Python in C\#, popularnost pa dobivajo tudi novejši jeziki kot so GoLang, Swift, Kotlin in podobni \cite{tiobeIndex}. \\
\indent S prevajalniki sem se začel ukvarjati pri predmetu Prevajalniki in navidezni stroji (PINS) v drugem letniku na Fakulteti za Računalništvo in Informatiko. Pri predmetu smo se osredotočili predvsem na enostavne proceduralne jezike, cilj diplomske naloge pa je vgradnja naprednejših gradnikov, ki niso bili del učnega načrta. V diplomski nalogi grobo opišem programske jezike in prevajalnike, v nadaljevanju predstavim programski jezik PINS, podrobneje pa se posvetim programskemu jeziku Atheris.

\chapter{Prevajalniki}
\label{ch0}

\section{Uvod v  programske jezike in prevajalnike}

Programski jezik je poseben jezik, ki se uporabljaja za razvoj programske opreme. Programski sistemi, ki poskrbijo, da se izvede pretvorba kode, napisane v programskem jeziku, v računalniku razumljivo obliko, se imenujejo prevajalniki. \\
Nekaj definicij:
\begin{enumerate}  
	\item \textbf{Računski model (angl. computational model):} zbirka vrednosti in računskih operacij 
	\item \textbf{Izračun (angl. computation)}: zaporedje operacij nad vrednostjo (ali več vrednosti), ki vrne nek rezultat
	\item \textbf{Program:} specifikacija izračuna
	\item \textbf{Programski jezik:} zapis (notacija) za pisanje programov
\end{enumerate}

Program lahko predstavimo kot funkcijo, pri kateri je rezultat (angl. \textit{output}) funkcija vhodnih parametrov (angl. \textit{input}):
\begin{lstlisting}
	rezultat = program(vhodni parametri)
\end{lstlisting}

Iz drugega zornega kota si lahko program predstavljamo tudi kot model problemske domene, kjer je instanca izvedbe programa simulacija problema \cite{computationalModel}:
\begin{lstlisting}
	program = model problemske domene
	izvedba programa = simulacija problema
\end{lstlisting}

\section{Zgradba prevajalnika}

Sodobni prevajalniki so pogosto organizirani v več posameznih faz, vsaka faza pa operira na drugem nivoju abstrakcije jezika \cite{modernCompiler}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{resources/compilerStructure.jpg}
	\end{center}
	\caption{Zgradba prevajalnika \cite{compilerStructure}.}
	\label{pic1}
\end{figure}

Da lahko prevajalnik program prevede iz ene oblike v drugo, ga najprej analizira, razume njegovo strukturo ter pomen, nato pa ga pretvori v drugačno obliko.  \\
Analizo programa običajno delimo v naslednje korake \cite{modernCompiler}:
\begin{enumerate}
	\item \textbf{Leksikalna analiza} (angl. \textit{lexical analysis})
	\item \textbf{Sintaksna analiza} (angl. \textit{syntax analysis})
	\item \textbf{Semantična analiza} (angl. \textit{semantic analysis})
\end{enumerate}

Po končani analizi sledi sinteza programa v izhodni / ciljni jezik. Sintezo do vmesne kode sestavljata:
\begin{enumerate}
	\item \textbf{Izračun klicnih zapisov} (angl. \textit{frame evaluation})
	\item \textbf{Generiranje vmesne kode} (angl. \textit{intermidiate code generation})
\end{enumerate}

\subsection{Leksikalna analiza}

Leksikalni analizator kot vhod prejme tok znakov, kot izhod pa vrne tok v naprej definiranih simbolov. Simbol je običajno zgrajen iz imena, vrednosti (t.i. \textit{lexeme}) ter lokacije v izvorni datoteki \cite{modernCompiler}.

\subsubsection{Leksikalni simboli:}

Simbol je zaporedje znakov, ki ga interpretiramo kot samostojno enoto v slovnici programskega jezika \cite{modernCompiler}. \\ 
Tabela \ref{tabel:vrsteZetonov} prikazuje nekaj vrst simbolov ter primere. \\

\begin{table}
	\begin{center}
		\begin{tabular}{l|c|c}
			\textbf{vrsta simbola} & \textbf{angl.} & \textbf{primeri} \\ \hline\hline
			ime & identifier & 
\begin{lstlisting} 
    x foo bar		
thisIsAnIdentifier
\end{lstlisting} \\
			rezervirana beseda & keyword & 
\begin{lstlisting} 
while for if		
public override
\end{lstlisting} \\
			operator & operator & 
\begin{lstlisting} 
, . && = ==
\end{lstlisting} \\
			niz znakov & string & 
\begin{lstlisting} 
"this is a string" 
\end{lstlisting} \\
			znak & character &
\begin{lstlisting} 
'a' 'x' '@'
\end{lstlisting} \\
			celo št. & integer &
\begin{lstlisting} 
10 125 082
\end{lstlisting} \\
			decimalno št. & real &
\begin{lstlisting} 
201.5 3.14 1.2e10
\end{lstlisting} \\
		\end{tabular}
	\end{center}
	\caption{Primeri simbolov v programskem jeziku Java.}
	\label{tabel:vrsteZetonov}
\end{table}

Sledi preprost primer programa v programskem jeziku Atheris ter rezultat leksikalne analize zanj.

\renewcommand{\lstlistingname}{Program}
\begin{lstlisting}[caption={Primer programa v programskem jeziku Atheris.},label={lst:atherisCode}, captionpos=b]
	let x: Int
	let y: Int
	x * y
\end{lstlisting}

\renewcommand{\lstlistingname}{Izpis}
\begin{lstlisting}[caption={Rezultat leksikalne analize za program ~\ref{lst:atherisCode}.},label={lst:lexedSource},captionpos=b]
	[1:1-1:4] 	LET:let
	[1:5-1:6] 	IDENTIFIER:x
	[1:6-1:7] 	COLON::
	[1:8-1:11] 	IDENTIFIER:Int
	[1:11-1:12] 	NEWLINE:\n
	[2:1-2:4] 	LET:let
	[2:5-2:6] 	IDENTIFIER:y
	[2:6-2:7] 	COLON::
	[2:8-2:11] 	IDENTIFIER:Int
	[2:11-2:12] 	NEWLINE:\n
	[3:1-3:2] 	IDENTIFIER:x
	[3:3-3:4] 	MUL:*
	[3:5-3:6] 	IDENTIFIER:y
	EOF:$
\end{lstlisting}

\subsection{Sintaksna analiza}

Druga faza prevajanja je sintaksna analiza (angl. \textit{syntax analysis} ali \textit{parsing}). Naloga te faze je, da zagotovi, da je napisan program slovnično pravilen in v skladu s sintaksnimi pravili. Sintaksni analizator prejme kot vhod tok simbolov, ki ga zgenerira prejšnja faza, rezultat pa je abstraktno sintaksno drevo. \\\\
\indent\textbf{Abstraktno sintaksno drevo} (AST) je drevesna podatkovna struktura, ki predstavlja sintaksno strukturo programa. Vsako vozlišče drevesa ponazarja konstrukt v programski kodi.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{resources/ast.png}
	\end{center}
	\caption{Abstraktno sintaksno drevo za program ~\ref{lst:atherisCode}.}
	\label{image:abstractSyntaxTree}
\end{figure}

Iz slike \ref{image:abstractSyntaxTree} lahko razberemo, da gre za dve definiciji spremenljivk in množenje.\\\\
\indent Abstraktno sintaksno drevo je bistvenega pomena, saj nadaljne faze operirajo izključno nad njim.

\subsection{Semantična analiza} \label{semanSection}

Semantična analiza poveže definicije spremenljivk z njihovimi uporabami ter preveri, ali so vsi izrazi pravilnih podatkovnih tipov \cite{modernCompiler}. \\
\indent Običajno izvedbo semantične analize razdelimo na dve pod-fazi:
\begin{enumerate}
	\item \textbf{Razreševanje imen:} zagotovi, da za vsako uporabo imena obstaja znotraj trenutnega območja vidnosti definicija z istim imenom, ter uporabo poveže z definicijo. \\
	Sledi primer, kjer se sklicujemo na nedefinirano spremenljivko:
	
	\renewcommand{\lstlistingname}{Program}
	\begin{lstlisting}[caption={Primer programa, kjer spremenljivka \textit{y} ni definirana.},label={lst:atherisCodeNameError},captionpos=b]
	let x: Int
	print(y)
	\end{lstlisting}
	
	\item \textbf{Preverjanje tipov:} vsakemu vozlišču v AST določi podatkovni tip, ter na podlagi postavljenih semantičnih pravil zagotovi, da so vsi izrazi pravilnih tipov. \\
	Sledi primer, kjer pride do napake pri razreševanju podatkovnih tipov (operacija '+' ni definirana nad podatkovnima tipoma \textit{String} in \textit{Int}):
	
	\renewcommand{\lstlistingname}{Program}
	\begin{lstlisting}[caption={Primer programa, kjer je napaka v podatkovnih tipih.},label={lst:atherisCodeTypeError},captionpos=b]
	let x: Int
	let s: String
	x + s
	\end{lstlisting}
	
\end{enumerate}

V zahtevnejših prevajalnikih se lahko tekom semantične analize opravi še dosti drugih analiz, npr. analiza inicializiranosti spremenljivk, zaznavanje mrtve kode, eliminacija neuporabljenih izrazov, ipd., vendar se z njimi tekom te diplomske naloge ne ukvarjamo.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{resources/astSeman.png}
	\end{center}
	\caption{Rezultat semantične analize za program ~\ref{lst:atherisCode}.}
	\label{image:astSeman}
\end{figure}

Pri implementaciji semantične analize nam pomaga \textit{simbolna tabela}.

\subsubsection{Simbolna tabela}

Simbolna tabela je podatkovna struktura, ki preslika imena v njihove definicije in podatkovne tipe \cite{modernCompiler}.  Ker običajno programi vsebujejo več tisoč definicij imen, mora podatkovna struktura omogočati učinkovito poizvedovanje. Iz slike ~\ref{image:astSeman} lahko razberemo, kaj se med izvajanjem semantične analize zgodi v ozadju: puščice predstavljajo povezave med definicijami in uporabami posameznih imen, evaluacija podatkovnih tipov pa je pri vseh vozliščih \textit{Integer}, razen pri korenu, ki nima tipa oz. je tipa \textit{Void}.\\
\indent Semantična analiza zagotovi, da za vsako uporabo imena obstaja njena definicija, in da so podatkovni tipi pravilni. Sliki \ref{image:astSemanCodeNameError} in \ref{image:astSemanTypeError} prikazujeta semantični napaki.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{resources/astSemanNameError.png}
	\end{center}
	\caption{Napaka v programu ~\ref{lst:atherisCodeNameError}; spremenljivka \textit{y} ni definirana.}
	\label{image:astSemanCodeNameError}
\end{figure}

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{resources/astSemanTypeError.png}
	\end{center}
	\caption{Napaka v programu ~\ref{lst:atherisCodeTypeError}; seštevanje med podatkovnima tipoma \textit{Integer} in \textit{String} ni dovoljeno.}
	\label{image:astSemanTypeError}
\end{figure}

\subsection{Klicni zapisi}

Klicni zapis je prostor v pomnilniku, ki vsebuje vse potrebne informacije za izvedbo posameznega klica funkcije. Običajno klicni zapis vsebuje prostor za lokalne spremenljivke, vhodne parametre in register, kamor se shrani izhodna vrednost funkcije. \\
\indent V skoraj vsakem modernem programskem jeziku ima lahko funkcija \textit{lokalne} spremenljivke. Ker lahko hkrati obstaja več klicev iste funkcije je pomembno, da ima vsak klic dostop do lastnih spremenljivk. Ta problem rešujemo s klicnimi zapisi \cite{modernCompiler}.  \\\\
\indent V funkciji 

\renewcommand{\lstlistingname}{Program}
\begin{lstlisting}
	func fib(_ n: Int) Int {
	    if n < 2 {
	        return 1
	    }
	    else {
	        return fib(n - 1) + fib(n - 2)
	    }
	}
	fib(10)
\end{lstlisting}

se za vsak njen klic ustvari nova instanca spremeljivke \textit{n}, ki živi na klicnem zapisu funkcije, vrednost pa ji priredimo kot vhodni argument. Ker je funkcija rekurzivna, živi v pomnilniku naenkrat veliko instanc spremenljivke \textit{n}, vsaka v lastnem klicnem zapisu \cite{modernCompiler}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{resources/stackFrame.png}
	\end{center}
	\caption{Klicni zapis \cite{stackFrames}.}
	\label{image:stackFramesImg}
\end{figure}

\subsubsection{Sklad}

Klicni zapisi funkcij se shranjujejo na sklad. Sklad je v pomnilniku predstavljen kot velika tabela s posebnim registrom imenovanim \textit{stack pointer}, ki kaže na konec sklada. Ob vsakem klicu funkcije se sklad poveča za velikost klicnega zapisa klicane funkcije. Podobno se ob vrnitvi funkcije zmanjša za enako vrednost. Prostor v klicnem zapisu namenjen hrambi vhodnih parametrov, lokalnih spremenljivk in ostalih registrov se imenuje klicni zapis \cite{modernCompiler}. 

\paragraph{Kazalec na klicni zapis:}

Predpostavimo da funkcija \textit{g} kliče funkcijo \textit{f}. Ob vstopu v f kazalec na sklad (SP) kaže na prvi vhodni argument funkciji f. Nov prostor na skladu je rezerviran tako, da se od SP odšteje velikost klicnega zapisa f. Tako SP sedaj kaže na konec sklada. Stara vrednost SP postane nova vrednost kazalca na klicni zapis (\textit{angl. frame pointer}). V programskih jezikih, kjer je velikost klicnega zapisa za posamezno funkcijo konstantna, je vrednost kazalca na klicni (FP) zapis vedno izračunljiva, zato si je ni potrebno posebaj shranjevati na sklad \cite{modernCompiler}: 

\begin{lstlisting}
	FP = SP + velikost klicnega zapisa
\end{lstlisting}

\paragraph{Prenos parametrov:}

Standarden način klicanja funkcij je, da klicoča funkcija rezervira prostor na skladu za prenosih njenih izhodnih parametrov (oz. vhodnih parametrov za klicano funkcijo) \cite{modernCompiler}. \\ 
\indent Prostor za njih se običajno nahaja pred SP. Klicana funkcija tako naslov njenega i-tega parametra izračuna z enačbo \\
\begin{lstlisting}
	argumentAddress(i) = FP + (4 * i)
\end{lstlisting}

\paragraph{Statična povezava:}

V jezikih, ki podpirajo gnezdenje funkcij, lahko gnezdene funkcije dostopajo do spremenljivk, ki se nahajajo v zunanjih funkcijah. Da lahko gnezdena funkcija dostopa do spremenljivk, ki niso na njenem klicnem zapisu, ji ob klicu poleg ostalih parametrov posredujemo FP funkcije, ki jo neposredno definira. Temu kazalcu rečemo statična povezava (angl. \textit{static link}). 

\renewcommand{\lstlistingname}{Program}
\begin{lstlisting}[caption={Primer gnezdenih funkcij.}, captionpos=b, label={lst:nestedFunctions}]
    func f() {
        var x: Int = 10
        func e() {
            var z: Int = 100
        }
        func g() {
            var y: Int = 20
            func h() {
                print(y, x)
            }
        }
    }
\end{lstlisting}

Program ~\ref{lst:nestedFunctions} vsebuje gnezdeni funkciji \textit{g} in \textit{h}. Funkcija h lahko dostopa do spremenljivk definiranih v \textit{g} in \textit{f}, ne pa tudi do tistih v \textit{e}.

\subsection{Generiranje vmesne kode}   

\subsubsection{Vmesna koda}

Vmesna koda (angl. \textit{intermidiate representation}) je abstraktni približek strojne kode, a brez mnogih podrobnosti posameznih strojnih jezikov. Vmesna koda (IR) predstavlja ukaze, brez da bi poznali arhitekturo ciljne naprave. Poleg tega je vmesna koda neodvisna od izvornega jezika \cite{modernCompiler}. \\
\indent Dobra predstavitev vmesne kode ima naslednje lastnosti \cite{modernCompiler}:

\begin{enumerate}
	\item Njeno generiranje mora biti priročno.
	\item Pretvorba vmesne kode v dejansko strojno kodo mora biti priročno za vse ciljne arhitekture.
	\item Vsak gradnik mora imeti jasen pomen, da so lahko optimizacijske transformacije enostavno implementirane.
\end{enumerate}

Poznamo dve vrsti vmesne kode: drevesno in linearno. Za ploščato vmesno kodo se pogosto uporablja t.i. \textit{three-address code} (TAC ali 3AC), kar pomeni, da imajo lahko ukazi take kode največ tri operande. \\
\indent Pri predmetu smo uporabili drevesno vmesno kodo, zato je tudi vmesna koda zgenerirana s strani prevajalnika za Atheris drevesna.\\
\indent Posamezni deli abstraktnega sintaksnega drevesa so lahko kompleksne stvari, na primer zanke, klici funkcij, itd., ki jih ne moremo neposredno preslikati v strojne ukaze. Zato morajo gradniki vmesne kode predstavljati le enostavne operacije, kot so npr. LOAD (preberi vrednost iz pomnilnika), STORE (shrani vrednost v pomnilnik), ADD (seštej dve vrednosti), itd. Tako lahko vsak posamezen del AST prevedemo v ravno pravo zsaporedje ukazov abstraktne vmesne kode \cite{modernCompiler}. \\ 

\chapter{Programski jezik PINS}

Programski jezik PINS je učni programski jezik, zato je tudi dokaj preprost. Prevajalnik zanj smo implementiral v sklopu domačih nalog pri predmetu Prevajalniki in navidezni stroji.

\section{Leksikalna pravila}

Programski jezik PINS podpira tri atomarne podatkovne tipe: \textit{integer}, \textit{logical}, \textit{string}, za katere so rezervirane istoimenske besede. Celoštevilske konstante so poljubno predznačeno zaporedje števk, logične konstante so ali \textit{true} ali \textit{false}, znakovne konstante pa so definirane kot poljubno (lahko prazno) zaporedje znakov z ASCII kodami med vključno 32 in 126, ki je obdano z enojnima navednicama (ASCII koda 39); izjema je en sam enojni narekovaj, ki je podvojen. \\
\indent Imena so definirana kot poljubno zaporedje črtk, številk in podčrtajev, ki se ne začne s številko in ni rezervirana beseda ali kakšna od prej naštetih konstant. \\
\indent Belo besedilo (\textit{angl. whitespace}) so presledki (ASCII 32), tabulatorji (ASCII 9) in znaka za konec vrstice (ASCII 10 in 13). \\
\indent Komentarji se začnejo z '\#' (ASCII 35) in se raztezajo do konca vrstice.

\section{Sintaksna pravila}

Celotna izvorna koda je sestavljena iz seznama definicij. Vsaka definicija je lahko:

\begin{enumerate}
	\item Definicija tipa (oz. sklic na tip - \textit{typealias})
	\item Definicija spremenljivke
	\item Definicija funkcije
\end{enumerate}

Kot sem že omenil, podpira PINS tri osnovne podatkovne tipe, vendar sintaksa omogoča tudi definicijo tabel (\textit{angl. array}) s fiksno velikostjo. \\
\indent Definicija funkcije je sestavljena iz imena, seznama parametrov, tipa ki ga funkcija vrača, ter \textit{izraza} oz. jedra funkcije. Zanimivo pri PINSu je to, da izven jedra funkcij ne moremo početi ničesar drugega, kot ustvarjati definicije (podobno kot pri Javi). \\
\indent S stališča sintaksne analize je Izraz (\textit{angl. expression}) lahko:
\begin{enumerate}
	\item Logični izraz
	\item Primerjalni izraz
	\item Seštevalni izraz
	\item Multiplikativni izraz
	\item Prefiksni izraz
	\item Postfiksni izraz
	\item Atomarni izraz
\end{enumerate}

Za uspešno izvedbo sintaksne analize atomarni izraz obsega naslednje:
\begin{enumerate}
	\item Logična konstanta
	\item Celoštevilska konstanta
	\item Znakovna konstanta
	\item Ime
	\item Klic funkcije
	\item If stavek
	\item If else stavek
	\item While stavek
	\item Zaporedje izrazov
\end{enumerate}

Zavedajmo se, da sestavljeni stavki, ki smo jih našteli kot atomarne izraze seveda niso nedeljivi s stališča jezika. Med atomarne izraze so vključeni zaradi upoštevanja prioritet aritmetičnih in logičnih operatorjev. Vsakemu izrazu lahko sledijo tudi definicije gnezdene znotraj zavitih oklepajev.

todo primeri

\section{Semantična pravila}

\subsubsection{Območja vidnosti}

Imena so vidna v celotnem območju vidnosti, ne glede na mesto definicije. Izraz \textit{expression \{ WHERE definitions \}} ustvari novo vgnezdeno območje vidnosti. To pomeni, da definicije znotraj zavitih oklepajev niso vidne navzven. Tudi definicija funkcije ustvari novo vgnezdeno območje vidnosti, ki se začne za imenom in se razteza do konca funkcije..

\subsubsection{Tipiziranost}

\begin{enumerate}
	\item \textit{integer}, \textit{logical}, \textit{string} opisujejo podatkovne tipe INTEGER, LOGICAL in STRING, zaporedoma
	\item izraz 
\begin{lstlisting}[]
	arr [ n ] type
\end{lstlisting}
	opisuje podatkovni tip ARR(n, type), kjer je \textit{n} celoštevilska konstanta 
\end{enumerate}

\subsubsection{Deklaracije}

\begin{enumerate}
	\item Deklaracija tipa
\[
typ\quad  identifier\quad  :\quad  type
\]
	ustvari sklic na podatkovni tip \textit{type} z imenom \textit{identifier}
	\item Deklaracija funkcije
%\begin{lstlisting}[]
\[ fun\quad identifier  ( identifier_1 : type_1, ..., identifier_n : type_n ) : type = expression \]
%\end{lstlisting}
	določa funkcijo, ki je tipa \[type_1 \quad *, \quad  ..., \quad *\quad  type_n \,\to\, type \]
	\item Deklaracija spremenljivke
\[
var \quad identifier\quad :\quad type
\]

določa spremeljivko tipa $type$
	\item Deklaracija parametra
\[
identifier \quad :\quad type
\]
določa parameter tipa $type$
\end{enumerate}

\section{Primeri}

Sledita dva primera podprogramov napisanih v programskem jeziku PINS (celotni programi se nahajajo v prilogi \ref{primeriPins}).

\begin{lstlisting}[caption={Sortiranje z navadnimi zamenjavami.}, captionpos=b]
	fun bubble(tab:arr[13] integer) : integer = (
	    {for i = 0, 13, 1 :
	        {for j = 0, 13, 1:
	            {if tab[j] > tab[i] then 
	            (
	                {tmp = tab[j]},
	                {tab[j] = tab[i]},
	                {tab[i] = tmp}, 0
	            ) 
	            { where var tmp : integer} }
	    	}
		},
		1
	) { where var i : integer; var j : integer };
\end{lstlisting}

\begin{lstlisting}[caption={Izračun n-tega fibonaccijevega števila..}, captionpos=b]
	fun fib(x : integer) : integer = (
	    { if x < 2 then
	        ({rez = 1})
	    else 
	        ({rez = fib(x - 1) + fib(x - 2)})
	    },
	    rez
	) {where var rez : integer};
\end{lstlisting}

\chapter{Programski jezik Atheris}
\label{ch1}

Kljub temu, da prevajalnik za Atheris izhaja iz prevajalnika za PINS, sta si jezika med seboj zelo različna. Razlikujeta se predvsem v sintaksi, ki je v programskem jeziku Atheris zelo podobna tisti, ki jo ima programski jezik Swift. Razlike med jezikoma so vidne v prilogi, ki vsebuje rešitve za tri znane probleme napisane v obeh jezikih. \\
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{resources/atheris.png}
	\end{center}
	\caption{Atheris Chlorechis (western bush viper) \cite{Atheris}.}
	\label{image:ast}
\end{figure}

\indent Med drugim nova sintaksa omogoča definiranje kompleksnejših podatkovnih tipov z uporabo razredov, vmesnikov, terk in enumeracij. \\
\indent Posamezni stavki so med seboj ločeni z novimi vrsticami (Python, Swift), vendar pa prevajalnik omogoča njihovo ločevanje tudi s podpičjem ';' (C++, Java). \\
\indent Komentarji se lahko začnejo bodisi z '\#' in se raztezajo do konca vrstice (Python, PINS), bodisi z '/*' in končajo z '*/' (Java, C++). \\
\indent Podprt je tudi \textit{switch} kontrolni stavek s sintakso identične tej od Swifta.\\
\indent Definicije funkcij ter klici funkcij so spremenjeni; parametri funkcije so sedaj sestavljeni iz labele ter imena parametra (tako kot v Swiftu). Pri klicu funkcije se uprabi labela parametra, znotraj jedra funkcije pa se uporablja ime.

\subsection{Podatkovni tipi}

Podprti atomarni podatkovni tipi so: \textit{integer, double, string, char} in \textit{bool}. Poleg atomarnih tipov pa so podprti tudi sestavljeni podatkovni tipi:

\begin{enumerate}
	\item Razredi
	\item Enumeracije
	\item Terke
	\item Vmesniki
\end{enumerate}

Poleg naštetih podatkovnih tipov obstaja še podatkovni tip, ki ga ni mogoče eksplicitno uporabljati. To je kazalec (\textit{angl. pointer}). Ena izmed prednosti kazalcev je v tem, da lahko do kompleksnejših objektov, ki v pomnilniku zasedejo veliko prostora, dostopamo preko njihovega naslova s kazalcem, namesto kopiranja celotne vsebine (na primer pri pošiljanju objekta kot argument funkciji). Spremeljivke, ki jim priredimo objekt, terko ali tabelo, se implicitno smatrajo kot kazalci. \\

\section{Sintaksa}

Celoten program v jeziku PINS je sestavljen iz seznama definicij, definicija pa je lahko definicija spremenljivke, definicija tipa ali definicija funkcije. Sintaksa programskega jezika Atheris se razlikuje v tem, da je program sestavljen iz zaporedja stavkov, stavek pa je lahko \textit{izraz} ali \textit{definicija}. Definicije so predstavljene z naslednjimi konteksno neodvisnimi gramatikami:

\begin{enumerate}
	\item Spremenljivke
\begin{lstlisting}[]
var_def -> visibility var identifier 
var_def -> visibility var identifier = expr
var_def -> visibility var identifier: type 
var_def -> visibility var identifier: type = expr 

visibility -> public
visibility -> private
visibility -> $
\end{lstlisting}
	\item Funkcije
\begin{lstlisting}[]
func_def -> prototype { statements }

prototype -> func identifier ( parameters )
prototype -> func identifier ( parameters ) type

parameters -> $
parameters -> paramater
parameters -> paramaters, paramater

parameter -> identifier : type
parameter -> identifier identifier : type
\end{lstlisting}	
	\item Enumeracije
	
\begin{lstlisting}
enum_def -> enum { enum_defs }

enum_defs -> $
enum_defs -> enum_member_def
enum_defs -> enum_defs, enum_member_def

enum_member_def -> case identifier
enum_member_def -> case identifier = expression (literal)
\end{lstlisting}
	\item Razredi
\begin{lstlisting}
class_def -> class { definitions }
\end{lstlisting}

\end{enumerate} 

Sintaksa izrazov je skoraj identična PINSu, razen izrazov za nadzor toka (angl. \textit{control flow}):

\begin{enumerate}
	\item If stavek
\begin{lstlisting}[]
if_expr -> if expr { statements }
if_expr -> if expr { statements } 
					 else_ifs else { exprs }

else_ifs -> $
else_ifs -> else if { statements } else { expr }
\end{lstlisting}
	\item Switch stavek
\begin{lstlisting}[]
switch_expr -> switch expr { cases }

cases -> case tuple_exprs: statements
cases -> default: statements

tuple_exprs -> expr
tuple_exprs -> expr, tuple_exprs
\end{lstlisting}
	\item While stavek
\begin{lstlisting}[]
while_expr -> while expr { statements }
\end{lstlisting}
	\item For stavek
\begin{lstlisting}[]
for_expression -> for identifier in expr 
{ statements }
\end{lstlisting}
	\item Terke
\begin{lstlisting}
tuple_expr -> ( tuple_exprs )

tuple_exprs -> expr
tuple_exprs -> expr, tuple_exprs
\end{lstlisting}
\end{enumerate} 

Kot sem že omenil, omogoča sintaksa programskega jezika Atheris, da so posamezni stavki ločeni bodisi s ';' bodisi z novo vrstico. Za ta namen je dodana nova vrsta simbolov, ki predstavlja novo vrstico v izvorni kodi (pred tem se je znak za novo vrstico štel kot belo besedilo). V primeru, da je v izvorni kodi več zaporednih novih vrstic, jih leksikalni analizator \textit{požre} in vedno vrne samo en zaporedni \textit{newline} simbol. To naredi sintaksno analizo enostavnejšo. 

\section{Funkcije}

Programski jezik Atheris zahteva, da ob klicu funkcij, poleg imena funkcije, navedemo tudi imena parametrov. Podobno kot to zahteva tudi Swift. \\
\indent Ob deklaraciji funkcije lahko opcijsko definiramo poljubno število poimenovanih ter tipiziranih vrednosti, ki jim skupaj rečemo parametri funkcije. Poleg tega lahko opcijsko navedemo še podatkovni tip vrednosti, ki jo bo funkcija vračala (privzeto funkcije ne vračajo ničesar - \textit{Void}.) \\
\indent Imena parametrov so sestavljena iz dveh delov: labele argumenta ter imena parametra. Labele argumentov se uporabljajo ob klicu funkcije, medtem ko se imena parametrov uporabljajo znotraj jedra funkcije. Labele so privzeto identične imenom.

\begin{lstlisting}[caption={Primer definicije in klica funkcije.}, captionpos=b]
func someFunction(firstParameterName: Int, secondParameterName: Int) {
  /* znotraj telesa funkcije, sta firstParameterName in secondParameterName referenci na vrednosti argumentov za prvi in drugi parameter. */
}
someFunction(firstParameterName: 1, secondParameterName: 2)
\end{lstlisting}

\subsection{Določanje label argumentov}

Če želimo, da sta labela in ime različna, navedemo labelo argumenta pred imenom:

\begin{lstlisting}[caption={Labela argumenta in ime parametra se razlikujeta.}, captionpos=b]
func someFunction(argumentLabel parameterName: Int) {
/* znotraj telesa funkcije, se parameterName sklicuje na vrednost argumenta funkciji */
}
someFunction(argumentLabel: 1) 
\end{lstlisting}

Podprta je tudi možnost, da se izognemo navajanju imen argumentov pri klicanju funkcij. To storimo tako, da označimo labelo argumenta z '\_'.

\begin{lstlisting}[caption={}, captionpos=b]
func someFunction(_ firstParameterName: Int, _ secondParameterName: Int) {
  #
}
someFunction(1, 2)
\end{lstlisting}

V ozadju so opisane funkcionalnosti implementirane tako, da se v simbolno tabelo ne shrani samo \textit{ime} funkcije, ampak se celotna definicija pretvori v posebno znakovno predstavitev, ki je sestavljena iz imena ter label argumentov. Funkcije z istim imenom, a različnimi imeni parametrov, lahko tako shranimo v simbolno tabelo brez težav.

\begin{lstlisting}[caption={Znakovne predstavitve funkcij.}, captionpos=b]
someFunction(firstParameterName:secondParameterName:)
someFunction(argumentLabel:)
someFunction(_:_:)
\end{lstlisting}

T.i. \textit{overloadanje} funkcij sedaj ni problem, saj čeprav imajo funkcije ista imena, se na vsako izmed njih sklicujemo preko različne predstavitve, zato jih lahko v simbolni tabeli ustrezno poiščemo. Seveda je potrebno v podobni obliki predstaviti tudi klice funkcij.

\section{Enumeracije}

Enumeracija je podatkovna struktura, ki definira skupen tip skupini povezanih vrednosti, in olajša delo nad njimi. Vsebuje lahko poljubno število vrednosti / konstant, ki jim lahko priredimo t.i. \text{surove vrednosti}. Podatkovni tip surovih vrednosti definiriamo v naprej in je pri vseh konstantah enak. \\
\indent V primeru, da enumeracija vsebuje surove vrednosti, jih je potrebno eksplicitno navesti za vse konstante enumeracije. Izjema so surove vrednosti za podatkovna tipa \textit{Int} in \textit{String}. \\
\indent Privzeto so surove vrednosti za \textit{Int} zaporedna števila začenši z 0. V primeru, da je vrednost eksplicitno navedena, je vrednost naslednje surove vrednosti naslednje zaporedno število od prejšnje vrednosti.

\begin{lstlisting}[caption={Enumeracija s surovimi vrednostmi tipa Int.}, captionpos=b]
	enum Days: Int {
	  case Monday # vrednost = 0
	  case Tuesday = 10 # vrednost = 10
	  case Wednesday # vrednost = 11
	  case Thursday = 100 # vrednost = 100
	  case Friday # vrednost = 101
	}
\end{lstlisting}

\indent Za \textit{String} so privzete surove vrednosti kar imena konstant.

\begin{lstlisting}[caption={Enumeracija s surovimi vrednostmi tipa String.}, captionpos=b, label={lst:fruitEnumeration}]
	enum Fruit: String {
	  case Apple # privzeta vrednost = "Apple"
	  case Orange = "Annoying Orange"
	  case Strawberry # privzeta vrednost = "Strawberry"
	}
\end{lstlisting}

\indent V primeru, da enumeracija nima surovih vrednosti, je semantična analiza dokaj preprosta. Kompleksnejša postane kadar so surove vrednosti prisotne, saj je potrebno zagotoviti, da so ustreznega podatkovnega tipa. V primeru, da surove vrednosti niso eksplicitno navedene, jih prevajalnik skuša določiti sam. To lahko stori samo v primeru, če so surove vrednosti tipa \textbf{Int} ali \textbf{String}. \\
\indent Do posameznih elementov enumeracije dostopamo z \textit{DOT} operatorjem ('.'), kjer je na levi strani ime enumeracije, na desni pa ime elementa. Podobno dostopamo tudi do surovih vrednosti z uporabo imena \textit{rawValue}. Operator zagotovi, da se v sestavljenem podaktovnem tipu na levi strani nahaja član z imenom na desni strani (več o operatorju v nadaljevanju).

\begin{lstlisting}[caption={Primer dostopa do elementov enumeracije ~\ref{lst:fruitEnumeration}.}, captionpos=b]
	print(Fruit.Apple.rawValue) # 'Apple'
	print(Fruit.Orange.rawValue)  # 'Annoying Orange'
	print(Fruit.Strawberry.rawValue)  # 'Strawberry'
\end{lstlisting}

Člane enumeracije lahko prirejamo spremenljivkam ter nad njimi izvajamo logični operaciji primerjanja vrednosti. 

\begin{lstlisting}[caption={}, captionpos=b]
	let x: Languages = Languages.Cpp
	if x == Languages.Java {
	    print("Java")
	}
	else {
	    print("Some other language")
	}
\end{lstlisting}

Da lahko realiziramo \textit{runtime} operacije nad člani enumeracije, prevajalnik vsak član enumeracije nadomesti z njegovim indeksom v definiciji enumeracije. Za zgornji primer bo tako spremeljivka \textit{x} vsebovala vrednost 0. V \textit{if} stavku primerjamo vrednosti 0 in 1, iz česar sledi, da se bo izvedel \textit{else} blok.

\section{Terke}

Terka je podatkovna struktura sestavljena iz poljubnega števila elementov, ki so lahko različnih podatkovnih tipov. Terke poznajo jeziki, kot sta Python in Swift, medtem ko jih Java in C++ ne poznata.\\
\indent Terka je definirana kot zaporedje izrazov znotraj oklepajev. Do posameznih elementov terke dostopamo podobno kot dostopamo do elementov v enumeraciji, ime elementa pa je kar njegov indeks v terki. 

\begin{lstlisting}[caption={Terka, sestavljena iz dveh vrednosti (Int, Double).}, captionpos=b]
	let x = (10, 5.5)
	print(x.0)
	print(x.1)
\end{lstlisting}

Vsakemu izrazu znotraj terke lahko opcijsko določimo tudi ime. V primeru, da ime ni eksplicitno določeno, se za ime uporabi indeks izraza v terki (začenši z 0).

\begin{lstlisting}[caption={Terka s poimenovanim elementom.}, captionpos=b]
	let x = (lorem: "Lorem", "Ipsum")
	print(x.lorem)
	print(x.1)
	# print(x.0) - napaka
\end{lstlisting}

\indent Do elementov prav tako dostopamo z uporabo DOT operatorja [todo], ki zagotovi, da terka vsebuje izraz z željenim imenom.\\
\indent V pomnilniku so terke predstavljene skoraj identično kot tabele, s to razliko, da se podatkovni tipi elementov med sabo lahko razlikujejo. Ravno zaradi tega ne moremo odmika izračunati na enak način kot pri tabelah, kjer indeks pomnožimo z velikostjo podatkovnega tipa. Pri terkah zato odmik posameznega elementa od začetnega naslova terke izračunamo tako, da seštejemo velikosti podaktovnih tipov vseh elementov pred željenim elementom:

\vspace{-7mm}
\[ offset ( element_i )  = sum ( size ( element_0 ), size( element_1 ), ..., size ( element_{n-1})) \]

Terke se pogosto uporabne v situacijah, kjer želimo, da funkcija vrne več vrednosti hkrati.

\begin{lstlisting}[caption={Funkcija, ki vrača dve vrednosti hkrati.}, captionpos=b]
	func evaluateBoard(_ ticTacToe: [Char]) (Int, Int) {
	    return (1, 10)
	}
	let eval = evaluateBoard(['X', ' ', 'X'])
	print(eval.0) # '1'
	print(eval.1) # '10'
\end{lstlisting}

\section{Razredi}

Razred je sestavljena podatkovna struktura, ki, podobno kot terka, v sebi hrani spremenljivke različnih podatkovnih tipov. Vsak razred lahko vsebuje poljubno število atributov (spremenljivk) ter poljubno število metod - to so člani rezreda. \\
\indent Atributi in metode so lahko statični, kar pomeni, da niso del posamezne instance razreda, ampak živijo v statični instanci, ki je kreirana avtomatsko. Poleg tega so lahko člani razreda \textit{privatni} ali \textit{javni}. Do privatnih članov ne moremo dostopati izven razreda. \\
\indent Metodam lahko dodamo modifikator \textit{final}, kar prepreči, da bi bila funkcija re-implementirana v dedujočem se razredu. Če želimo, da metoda re-implementira metodo v starševkem razredu, ji moramo dodati modifikator \textit{overriding}. \\
\indent Poleg atributov in metod lahko razred vsebuje tudi definicije gnezdenih razredov, enumeracij ter vmesnikov.\\
\indent V pomnilniku je instanca razreda (objekt) predstavljena podobno kot terka, t.j. kot tabela z vrednostmi različnih podatkovnih tipov. Zato tudi odmik elementov računamo na enak način.

\subsection{Dostop do članov in nadzor dostopa}

Do članov razreda dostopamo preko DOT operatorja. DOT operator je binarni operator in je sestavljen iz dveh izrazov, ki ju povezuje pika '.'. \\
\indent Običajno se izvaja povezovanje uporab spremenljivk z definicijami v fazi razreševanja imen, vendar to pri sestavljenih podatkovnih strukturah (vključno z enumeracijami in terkami) ni mogoče.\\
\indent Zato se s tem ne ukvarjamo v razreševanju imen, ampak problem prepustimo razreševanju tipov. Razreševanje tipov zato delimo na dve pod-fazi (dva sprehoda po AST). V prvem sprehodu nas zanimajo samo podatkovni tipi definicij, izraze zaenkrat pustimo pri miru. Ko zberemo vse potrebne informacije o podatkovnih tipih članov razreda, lahko zgradimo razredni tip, ki predstavlja razred in njegove definicije. \\
\indent Sedaj imamo dovolj informacij, da razrešimo imena znotraj DOT operatorja, kar storimo v drugem sprehodu.\\

\textbf{Nadzor dostopa}

Nadzor dostopa omejuje dostop do članov razreda izven definicije, če to eksplicitno navedemo z uporabo modifikatorja \textit{\textbf{private}}. Privzeto so vsi člani \textit{\textbf{public}}. Programski jezik Atheris trenutno pozna samo public in private modifikatorja; public modifikator omogoča dostop do in spreminjanje vrednosti člana razreda kodi, ki se ne nahaja v razredu, za razliko od modifikatorja private, ko to prepoveduje. 

\subsection{Instančne funkcije}

Razred ima lahko v sebi definirane funkcije, ki se jim v OOP žargonu pogosto reče \textit{metode}. Metode se od funkcij, ki niso definirane v razredu, razlikujejo v tem, da vsebujejo impliciten parameter, ki je referenca na objekt, ki metodo kliče. Ta parameter prevajalnik v metodo vstavi avtomatsko. \\
\indent V C++ in Javi se ta parameter imenuje \textbf{\textit{this}}, v Pythonu, Swiftu in v Atherisu pa \textbf{\textit{self}}. V Pythonu je ta razlika, da je parameter potrebno eksplicitno navesti, če ga ne, se funkcija / metoda smatra kot statična (več o statičnih metodah v nadaljevanju). \\
\indent Prevajalnik mora implicitni \textit{self} parameter avtomatsko vstaviti v vse metode razreda. Delno to stori tekom razreševanja imen, ko definiciji funkcije vstavi nov parameter, delno pa tekom razreševanja tipov, ko parametru nastavi tip. \\

\subsection{Konstruktorji}

Konstruktorji so posebne vrste metod, njihova naloga pa je kreacija objektov ter inicializacija atributov. Podobno kot ostalim metodam razreda tudi konstruktorju prevajalnik implicitno vstavi \textit{self} parameter. \\
\indent Naloga konstruktorja je, da na kopici, t.j. delu pomnilnika, kamor shranjujemo dinamično alicirane objekte (za razliko od sklada, kamor shranjujemo statične), alocira prostor, kjer bo shranjen objekt. Za dinamično alociranje pomnilnika se uporabi gradnik vmesne kode \textbf{ImcMALLOC}. Ta gradnik na kopici rezervira željeno velikost pomnilnika ter vrne naslov. \\
\indent Pri generiranju vmesne kode prevajalnik vstavi na začetek kode konstruktorja MALLOC gradnik, ki bo rezerviral prostor za objekt. Nato bo prevajalnik vrnjen naslov shranil na sklad v parameter \textit{self}, zato da lahko znotraj konstruktorja nastavimo vrednosti ostalih atributov razreda. Na koncu bo ta naslov konstruktor tudi vrnil. Vrnjen naslov je referenca na objekt in ga uporabljamo za nadaljne operacije nad objektom. \\
\indent Razred ima lahko poljubno število konstruktorjev, ki jih definiramo z uporabo ključne besede \textit{\textbf{init}}. 

\begin{lstlisting}[caption={Konsturktorji.}, captionpos=b]
	class Atheris {
	    var x: Int
	    init() {
	        self.x = 0
	    }
	    init(x: Int) {
	        self.x = x
	    }
	}
\end{lstlisting}

\indent Poleg eksplicitnih konstruktorjev prevajalnik zgenerira tudi impliciten \textit{privzeti} konstruktor. Vanj je vstavljena koda za inicializacijo atributov, ki so inicializirani ob definiciji. 

\begin{lstlisting}[caption={Implicitni privzeti konstruktor.}, captionpos=b]
	class Atheris {
	    var x: Int = 10
	    var y: Int = 20
	}
	
	print(Atheris().x) # 10
	print(Atheris().y) # 20
\end{lstlisting}

V primeru, da je v razredu privzeti konstruktor tudi eksplicitno definiran, bo poleg svoje kode vseboval tudi kodo implicitnega.

\begin{lstlisting}[caption={Eksplicitni privzeti konstruktor.}, captionpos=b]
	class Atheris {
	    var x: Int = 10
	    var y: Int = 20
	    init() { # privzeti konstruktor
	        self.y = 100
	    }
	}
	
	print(Atheris().x) # 10
	print(Atheris().y) # 100
\end{lstlisting}

\subsection{Statični člani razreda}

Statični člani razreda so tisti člani, ki ne živijo znotraj posameznih instanc, ampak živijo v globalni statični instanci razreda. Definiramo jih z uporabo modifikatorja \textit{\textbf{static}}. Statična instanca razreda je naložena v pomnilnik avtomatsko ob zagonu programa. Do statičnih članov dostopamo preko imena razreda. Ker statične funkcije niso del instance razreda, ne vsebujejo \textit{self} parametra.

\begin{lstlisting}[caption={Klicanje statične funkcije.}, captionpos=b]
	class Static {
   	    static func foo() {
	         print("I am a static function")
	    }
	} 
	Static.foo()
\end{lstlisting}

\indent V času razreševanja tipov so statične definicije razreda shranjene v ločeno podatkovno strukturo od instančnih. Vozlišču AST, ki definira razred (\textit{AstClassDefinition}), v simbolno tabelo ne pripišemo razredni podatkovni tip, ampak \textit{statični} tip, ki hrani podatke o statičnih definicijah razreda. Ko se sklicujemo na člane statične instance preko DOT operatorja, prevajalnik preveri, ali statični tip vsebuje iskan član.\\
\indent Razredi lahko vsebujejo tudi enumeracije in gnezdene razrede. Definicije enumeracij in razredov se privzeto smatrajo kot statične, zato do njih dostopamo enako kot do statičnih članov. 

\begin{lstlisting}[caption={Enumeracija znotraj razreda.}, captionpos=b]
	class Static {
	    enum Languages: Int {
	        case Cpp, Java
	    }
	}
	let x = Static.Languages.Java
	print(x.rawValue) # '1'
\end{lstlisting}

Da lahko dostopamo do konstruktorjev znotraj gnezdenih razredov, jih prevajalnik avtomatično potisne v seznam statičnih metod razreda.

\begin{lstlisting}[caption={Gnezden razred.}, captionpos=b]
	class Atheris {
	    class NestedClass {
	        var x = 20
	    }
	}
	print(Atheris.NestedClass().x) # '20'
\end{lstlisting}

\section{Dedovanje in polimorfizem}

Dedovanje in polimorfizem sta, poleg enkapsulacije in abstrakcije, najpomembnejša koncepta OOP programiranja. Dedovanje je mehanizem, s katerim objekt pridobi (podeduje) nakatere ali vse lastnosti drugega objekta, medtem ko je polimorfizem sposobnost predstaviti isto funkcionalnost z različnimi implementacijami. Programski jezik Atheris omogoča enkratno dedovanje, tako kot Java in Swift. \\
\indent V pomnilniku se atributi dedovanega razreda nahajajo pred atributi dedujočega se razreda. Enačba za izračun velikosti razreda (koliko prostora porabi objekt v pomnilniku) postane kompleksnejša, saj je potrebno rekurzivno prišteti velikosti nadrazradov. Prav tako postane komleksnejši izračun odmikov atributov od začetnega naslova. 

\subsection{Dynamic Dispatch} \label{dynamicDispatch}
[todo]
Dynamic dispatch je proces izbire, katera implementacija polimorfne operacije naj se izvede v času \textbf{izvajanja} programa. Običajno lahko pri klicih funkcij že v času prevajanja izberemo, katera implementacija funkcije naj se kliče, saj obstaja samo ena. Pri razredih nastane problem, kadar dovolimo, da imajo lahko dedujoči se razredi svoje implementacije funkcij (oz. metod), kot je razvidno v spodnjem primeru: 

\begin{lstlisting}[caption={Več implementacij za isto funkcionalnost.}, captionpos=b, label={virtualTableExamples}]
	class Fruit {
	    func kind() {
	        print("I am a Fruit!")
	    }
	}
	class Apple: Fruit {
	    override func kind() {
	        print("I am an Apple!")
	    }
	}
	class Orange: Fruit {
	    override func kind() {
	        print("I am an Orange!")
	    }
	}
\end{lstlisting}

\indent Problem je možno rešiti na več načinov. Rešitev prevajalnika za Atheris temelji na rešitvi, ki jo ima tipično C++, t.j. z uporabo podatkovne strukture \textit{\textbf{v-table}}. 

\subsubsection{Virtualna tabela}

Virtualna tabela je podatkovna stuktura, ki vsebuje kazalce na funkcije implementirane v danem razredu. Prevajalnik za vsak razred zgenerira in shrani v pomnilnik unikatno virtualno tabelo. \\
\indent Vsak objekt v pomnilniku, poleg svojih atributov, hrani še kazalec na lastno virtualno tabelo.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1.1\textwidth]{resources/vtables.png}
	\end{center}
	\caption{Virtualne tabele za dane razrede iz ~\ref{virtualTableExamples}.}
	\label{vtables}
\end{figure}

Virtualna tabela vsebuje kazalce na naslove, kjer se nahajajo vse ne-statične metode, ki so implementirane v razredu. Vsaka tabela vsebuje še kazalec na virtualno tabelo nadrazreda (ali \textit{null}, če ga nima), ter unikatni identifikator tipa. Identifikator je pozitivno celo število, ki ga prevajalnik dodeli vsakemu tipu in je unikaten za vsak tip. \\

\subsection{Realizacija}

Problem rešimo tako, da kazalec na metodo shranimo v virtualno tabelo na tisti indeks, na katerem je motoda definirana v razredu. Prevajalnik za klic funkcije zgenerira vmesno kodo, ki izračuna naslov metode z naslednjo enačbo:

\[ address(method_i) = adress(vtable) + (i * sizeof(void*) + 8) \]

kjer je \[address(vtable)\]\ lokacija tabele v pomnilniku, \[(i * sizeof(void*) + 8)\] indeks pomnožen z velikostjo kazalca (običajno 4 byti) plus odmik od začetka tabele zaradi prej opisanih dodatnih podatkov v tabeli in \[ address(method_i)\] naslov metode na indeksu i.

\section{Vmesniki}

Vmesnik je abstraken opis akcij, ki jih lahko izvede objekt. Tekom prevajanja prevajalnik zagotovi, da razred vsebuje vse metode v vmesnikih, ki jih želi implementirati. Ker je vmesnik abstraktna podatkovna struktura, ne moremo kreirati instance neposredno, lahko pa spremeljivki priredimo instanco razreda, če razred implementira vmesnik. Vse metode so klicane dinamično, po postoku opisanem v razdelku \ref{dynamicDispatch}.

\begin{lstlisting}[caption={Primer uporabe vmesnikov.}, label={lst:interfaces}, captionpos=b]
	interface I {
	    func foo()
	}
	class A: I {
	    func foo() {
	        print("A's implementation of foo")
	    }
	}
	class B: I {
	    func foo() {
	        print("B's implementation of foo")
	    }
	}
	var x: I
	x = A()
	x.foo() # 'A's implementation of foo'
	x = B()
	x.foo() # 'B's implementation of foo'
\end{lstlisting}

\section{Abstraktni razredi}

Programski jezik Atheris dopušča zmožnost deklariranja abstraktnih razredov z uporabo rezervirane besede \textit{abstract}. Značilnost abstraktnih razredov je to, da ne moremo kreirati njihov instanc neposredno. Abstraktni razredi s tem dopuščajo možnost definiranja abstraktnih metod, ki jih mora vsak dedujoči-se ne-abstraktni razred implementirati. V tem pogledu so si abstraktni razredi in vmesniki zelo podobni. Abstraktne metode definiramo tako kot razrede z uporabo ključne besede \textit{abstract}.

\begin{lstlisting}[caption={Primer uporabe abstraktnih razredov.}, captionpos=b]
	abstract class Shape {
	    var len: Int
	    abstract func area() Int
	}
	
	class Square: Shape {
	    init(_ len: Int) {
	        self.len = len
	    }
	    func area() Int {
	        return self.len * self.len
	    }
	}
	
	class Rect: Shape {
	    var height: Int
	    init(width: Int, height: Int) {
	        self.len = width
	        self.height = height
	    }
	    func area() Int {
	        return self.len * self.height
	    }
	}
	
	var shape: Shape
	shape = Square(10)
	print(shape.area()) # '100'
	shape = Rect(width: 5, height: 10)
	print(shape.area())  # '50'
\end{lstlisting}

Naloga prevajalnika je, da zagotovi, da so v razredu implementirane vse abstraktne metode, ki so definirane v hiearhiji razredov. Če ne želimo implementirati vseh metod abstraktnega razreda, mora biti razred označen kot abstrakten. \\
\indent Definirajmo abstraktni podatkovni strukturi seznam in sklad, ki definirata ustrezne abstraktne operacije:

\begin{lstlisting}[caption={}, captionpos=b]
	abstract class AbstractList {
	    private var storage: [Int]
	    abstract func append(_ val: Int)
	    abstract func remove(at index: Int)
	}
	
	abstract class AbstractStack: AbstractList {
	    abstract func push()
	    abstract func pop()
	}
\end{lstlisting}

Razred, ki želi dedovati od \textit{AbstractStack}, mora poleg metod \textit{push} in \textit{pop} implementirati tudi obe metodi v \textit{AbstractList} razredu:

\begin{lstlisting}[caption={Implementacija abstraktne podaktovne strukture.}, captionpos=b]
	class Stack: AbstractStack {
	    func append(_ val: Int) {}
	    func remove(at index: Int) {}
	    func push() {}
	    func pop() {}
	}
\end{lstlisting}

\section{Instance of operator}

[todo]
Instance of operator je operator, ki v času izvajanja programa preveri, ali je objekt instanca danega razreda. To naredi z uporabo virtualne tabele. Kot je bilo omenjeno, vsaka tabela vsebuje unikatni deskriptor njenega razreda. Preko deskriptorja lahko preverimo, ali se dva podatkovna tipa ujemata. \\
\indent V programskem jeziku Atheris se operator imenuje \textit{is}.

\begin{lstlisting}[caption={Uporaba operatorja \textit{is} za razrede iz sheme ~\ref{vtables}.}, captionpos=b]
	var object: A
	object = B()
	print(object is A) # 'true'
	print(object is B) # 'true'
	print(object is C) # 'false'
\end{lstlisting}

Ker je lahko razredna hiearhija obsežna, je potrebno preverjanje izvesti rekurzivno po celotni hiearhiji.

\begin{lstlisting}[caption={Algoritem za izračun ali je objekt instanca danega razeda.}, captionpos=b]
todo
\end{lstlisting}

\section{Pretvarjanje tipov}

Mehanizem pretvarjanja iz enega tipa v drug (angl. \textit{type casting}) deluje po zelo podobnem principu kot \textit{as} operator. Razlikujeta se predvsem v njunem rezultatu. Rezultat \textit{as} operatorja je \textit{true} ali \textit{false}, medtem ko je pri neuspešnem pretvarjanju rezultat \textit{null}, pri uspešnem pa objekt, pretvorjen v željen tip. Takemu tipu pretvarjanja rečemo \textit{safe casting}, saj program nadaljuje z izvajanjem tudi če pretvorba ni uspešna. Za razliko od \textit{non-safe castanja}, kjer bi program vrnil \textit{null pointer exception}.

\begin{lstlisting}[caption={Pretvorba za razrede iz sheme ~\ref{vtables}.}, captionpos=b]
	var object: A = B()
	let casted = object as B
	    print("cast failed")
	}
	else {
	    print("cast succeeded") # izvede se 'else' blok
	}
\end{lstlisting}

\section{Razširitve}

Razširitev (angl. \textit{extension}) je mehanizem, ki omogoča dodajanje funkcionalnosti obstoječim razredom. Razred lahko razširimo z metodami, enumeracijami in razredi.  

\begin{lstlisting}[caption={Razširitev razreda A.}, captionpos=b]
	extension A {
	    func toString() {
	        print("ext::toString()")
	    }
	}
	A().toString()
\end{lstlisting}

Implementacija razširitev ni ravno zapletena; prevajalnik v fazi razreševanja tipov tekom prvega sprehoda po AST za vsako novo definicijo v razširitvi izračuna njen podatkovni tip, zagotovi, da razred ne vsebuje definicije z istim imenom, ter mu jo na koncu vstavi.

\subsection{Razširitev z vmesnikom}

Razredom lahko preko razširitev dodamo tudi implementacijo vmesnikov, čemur rečemo \textit{interface extension}.

\begin{lstlisting}[caption=Razširitev z vmesnikom., captionpos=b]
	class Collection {}
	interface Iterable {
	    func next() Int
	}
	extension Collection: Iterable {
	    func next() Int {
	        return 10
	    }
	}
	let iterable = Collection()
	print(iterable.next())
\end{lstlisting}

\section{Type inference}

[todo]
Type inference omogoča prevajalniku, da avtomatsko prepozna podatkovni tip izraza, na podlagi vrednosti, ki so v izrazu. To je posebej uporabno pri definicijah spremeljivk, ki jim pogosto nastavimo vrednost ob sami definiciji. \\
\indent V primeru, da definicija spremenljivke nima eksplicitno navedenega podatkovnega tipa, prevajalnik najprej izračuna podatkovni tip izraza na desni strani prirejevalnega operatorja, ter ga nato dodeli definiciji.

\begin{lstlisting}[caption={Avtomatično prepoznavanje podatkovnih tipov.}, captionpos=b]
	let meaningOfLife = 42
	# meaningOfLife je tipa Int
	let pi = 3.14159
	# pi je tipa Double
	let anotherPi = 3 + 0.14159
	# anotherPi je tudi tipa Double
\end{lstlisting}

Prepoznavanje tipov postane kompleksnejše pri tabelah, kadar njeni elementi niso istih tipov. Prevajalnik tekom razreševanja tipov vedno poišče najmanjši možen tip, ki je skupen vsem elementom tabele. V primeru, da so v tabeli objekti, ki jim je skupen nadrazred \textit{A}, bo tudi tabela tipa \textit{A}. V primeru, da elementi nimajo nobenega skupnega tipa, prevajalnik tabeli dodeli poseben abstrakten tip \textit{\textbf{Any}}, ki je definiran v standardni knjižnici. \textit{Any} je v programskem jeziku Atheris to, kar je v Javi \textit{Object}, s to razliko, da je \textit{Object} razred, \textit{Any} pa vmesnik. Vsak podatkovni tip je implicitno tudi tipa \textit{Any} .

\begin{lstlisting}[caption={Elementi tabele s skupnim nadrazredom.}, captionpos=b]
	let array = [C(), B(), C(), C()] # spremenljivka array = tipa ARR ( A )
\end{lstlisting}

\begin{lstlisting}[caption={Elementi tabele nimajo skupnega tipa.}, captionpos=b]
	let array = [10, "string", A(), 3.14] # spremenljivka array = tipa ARR ( Any )
\end{lstlisting}

\chapter{Meritve in testiranje}

Delovanje programskega jezika Atheris je testirano na znanih algoritmih - \textit{bubble sort}, \textit{quick sort} in \textit{fibonacci}. Testni primeri so izbrani tako, da preko njih preizkusimo delovanje čim večih funkcionalnosti jezika. Kot zanimivost je izmerjena tudi hitrost izvajanja programov in primerjana z osnovnim jezikom, za referenco pa je izmerjena še hitrost delovanja algoritmov v Pythonu (vsi rezultati v nadaljevanju so prikazani v sekundah).

\section{Meritve}

\subsection{Bubblesort}

Z bubblesort algoritmom preverimo:

\begin{itemize}
	\item dostopanje do pomnilnika (do elementov v tabeli na nekem indeksu),
	\item delovanje zank,
	\item klicanje funkcij, prenos parametrov.
\end{itemize}
Algoritem smo izvedli 100.000-krat na številih \textit{8, 0, 3, 9, 2, 14, 10, 27, 1, 5, 8, -1, 26} in pri tem merili čas izvajanja.

\begin{figure}[!]
	\centering
\begin{tikzpicture}
\begin{axis}[
symbolic x coords={PINS, Atheris, Python},
xtick=data,
bar width=40,
width=300,
ylabel={Čas (sekunde)},
xlabel={Programski jezik}]
]
\addplot[ybar,fill=blue] coordinates {
	(PINS,   29.802)
	(Atheris,  28.535)
	(Python,   2.017)
};
\end{axis}
\end{tikzpicture}
\caption{Bubblesort (sortiranje z navadnimi zamenjavami).}
\end{figure}

Rezultati niso presenetljivi, PINS in Atheris oba potrebujeta približno enako časa, medtem ko je Python (po pričakovanjih) bistveno hitrejši.

\subsection{Quicksort}

Z uporabo quicksort algoritma, poleg prej naštetih funkcionalnosti, stestiramo še delovanje rekurzije. Algoritem je izveden pod enakimi pogoji kot bubblesort. \\

\begin{figure}
	\centering
\begin{tikzpicture}
\begin{axis}[
symbolic x coords={PINS, Atheris, Python},
xtick=data,
bar width=40,
width=300,
ylabel={Čas (sekunde)},
xlabel={Programski jezik}]
]
\addplot[ybar,fill=blue] coordinates {
	(PINS,   34.600)
	(Atheris,  18.449)
	(Python,   1.507)
};
\end{axis}
\end{tikzpicture}
\caption{Quicksort.}
\end{figure}

Rezultat je izjemno zanimiv, saj je Atheris hitrejši PINSa za več kot 200\%, kljub temu, da prevajalnik za Atheris ne vsebuje veliko optimizacij. \\
\indent Po podrobni analizi se izkaže, da sta za tako razliko v hitrosti izvajanja algoritma kriva dva razloga:

\begin{itemize}
	\item Programski jezik PINS ne podpira izrazov za prenos toka (angl. \textit{control transfer}), to sta običajkno \textit{break} in \textit{continue}, zato je potrebno algoritem implementirati z uporabo začasnih spremenljivk, zaradi česar se izvede občutno večje število ukazov za izvedbo algoritma v PINS interpreterju.
	
	\item Drug razlog za tako občutno razliko pa je to, da je klicanje funkcij v Atherisu hitrejše. Izkaže se da quicksort algoritem izvede veliko večje število klicev funkcij, kar je smiselno, glede na to, da je algoritem rekurziven. \\
	\indent Klici funkcij so v Atherisu implementirani tako, da se koda funkcije pred začetkom izvajanja programa shrani v pomnilnik, do kode pa dostopamo prek labele. Interpreter vsebuje preslikavo iz labele na naslov kode funkcije v pomnilniku, kar nam omogoča izvedbo funkcije. V PINSu funkcij ne shranjujemo v pomnilnik, 
\end{itemize}

\subsection{Izračun n-tega fibonaccijevega števila}

Zadnji testni algoritem je izračun n-tega fibonaccijevega števila z uporabo rekurzivne enačbe
$fib(n) = fib(n - 1) + fib(n - 2) ; fib(0) = 1; fib(1) = 1$. Računamo $fib(35)$. \\

\begin{figure}[H]
	\centering
\begin{tikzpicture}
\begin{axis}[
symbolic x coords={PINS, Atheris, Python},
xtick=data,
bar width=40,
width=300,
ylabel={Čas (sekunde)},
xlabel={Programski jezik}]
]
\addplot[ybar,fill=blue] coordinates {
	(PINS,  34.874)
	(Atheris, 32.308)
	(Python, 3.019)
};
\end{axis}
\end{tikzpicture}
\caption{Izračun n-tega fibonaccijevega števila.}
\end{figure}

\subsection{Quicksort s polimorfnimi operacijami}

V razdelku ~\ref{dynamicDispatch} je podrobneje opisano delovanje polimorfnih operacij, kot so \textit{dynamic dispatch}, \textit{instance of} operator ter pretvarjanje tipov. Naštete operacije nam omogočajo kar nekaj priročnih funkcionalnosti, ki nam pri razvoju programske opreme pogosto pridejo prav. A pod določeno ceno, saj je izvedba teh operacij relativno počasna. \\
\indent Zanimalo me je, kakšna je dejansko cena, ki jo moramo plačati za njihovo delovanje. Pripravljen je primer, ki testira prav to.
Gre za implementacijo quick sort algoritma, ki se izvaja nad identičnimi vhodnimi podatki kot prejšnji primeri, s to razliko, da so števila ovita v objekte. Izvajanje primerjanja dveh objektov poteka z uporabo naštetih polimorfnih operacij. \\

\begin{tikzpicture}
\begin{axis}[
symbolic x coords={PINS, Atheris, Atheris - razredi},
xtick=data,
bar width=40,
width=300
]
\addplot[ybar,fill=blue] coordinates {
	(PINS,   34.600)
	(Atheris,  18.449)
	(Atheris - razredi,   42.874)
};
\end{axis}
\end{tikzpicture}

Po pričakovanjih se izkaže, da je izvajanje res občutno počasnejše; in sicer skoraj 230\%. 

\chapter{Sklepne ugotovitve}

V okviru diplomske naloge so predstavljeni programski jeziki in prevajalniki, sodobne prakse načrtovanja in implementacije prevajalnikov ter njihova zgradba. Podrobneje sta opisana programska jezika PINS in Atheris, poudarek na slednjem, ki je nadgradnja prvega. Razširitve, ki jih prevajalnik za Atheris vsebuje napram prevajalniku za PINS, in njihova implementacija, so tekom naloge podrobneje opisane. \\
\indent Programski jezik Atheris omogoča uporabo objektno usmerjenih gradnikov, ki jih vidimo v večini sodobnih objektnih jezikov; to so enumeracije, terke, razredi in vmesniki. Atheris podpira tudi razširitve razredov, podobno kot to lahko počnemo v Swiftu. \\
\indent Za diplomsko nalogo je bilo načrtovano še kar nekaj dodatnih funkcionalnosti, ki zaenkrat še niso implementirane. Med njih spadajo generični podatkovni tipi in generične funkcije, opcijski podatkovni tipi in \textit{closure} \footnote{todo razlaga} funkcije. Njihova vgradnja bo prišla na vrsto v nadaljnem razvoju prevajalnika. \\
\indent  V razdelku ~\ref{semanSection} je omenjeno, da lahko semantična analiza stori več, kot le razreši imena in podatkovne tipe. Prevajalnik za Atheris vsebuje še tretjo semantično fazo, ki se imenuje \textit{preverjanje inicializiranosti}. Naloga te faze je, da za vsako spremenljivko zagotovi, da ji je bila pred njeno uporabo nastavljena vrednost. Poleg tega prepreči, da lahko konstantam vrednost priredimo natanko enkrat. Faza je trenutno še v povojih in zaenkrat ne deluje tako, kot bi si želeli, zato ni opisana tekom diplomske naloge. \\
\indent Tekom te diplomske naloge se osredotočamo predvsem na \textit{front-end} del prevajalnika, kjer se izvede analiza izvorne kode in sinteza v vmesno. Preskočen je celoten zaledni del prevajalnika (\textit{back-end}). Naloga zalednega dela je optimizacija vmesne in generiranje dejanske strojne kode za ciljno arhitekturo. V prihodnje je cilj vgradnja v prevajalnik za Atheris izjemno močen zaledni sistem \textbf{LLVM} \cite{LLVM}, na katerem temeljijo tudi zelo zmogljivi C++, Objective-C in Swift prevajalniki.

