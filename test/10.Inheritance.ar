import stdlib

class A {
	func a() {
		print(string: "A::a()")
	}

	let A_a: Int = 10

	func foo() {
		print(string: "A::foo()")
		self.a()
		self.joze()
	}
}

class B: A {
	
	let B_b: Int = 33

	override func a() {
		print(string: "B::a()")
	}

	func b() {
		print(string: "B::b()")
	}

	override func joze() {
		print(string: "extension::B::joze()")
	}
}

class C: B {
	override func a() {
		print(string: "C::a()")
	}

	let C_c: Int = 100
}

########################

var a: A
let x: Int = 30

if x == 10 {
	a = A()
}
else if x == 20 {
	a = B()
}
else {
	a = C()
}

a.a()

C().foo()
C().b()
C().joze()

print(integer: C().A_a)
print(integer: C().B_b)
print(integer: C().C_c)

#######################

var object: A = C()

let casted = object as B

if casted != null {
	casted.b()
}
else {
	print(string: "cast failed")
}

#######################

extension A {

	func joze(a: Int) {
		print(string: "extension::A::joze(a:)")
		print(integer: a)
	}

	func joze() {
		print(string: "extension::A::joze()")
	}
}


A().foo()
A().joze(a: 10)
A().joze()
B().joze(a: 20)
B().joze()
B().a()

#######################

/*struct Point {
	var x: Int = 3333
	var y: Int = 5555
}

var p1 = Point()

extension Point {
	func test() {
		print(string: "extension::Point::test()")
		print(integer: self.x)
	}
}

var p2 = p1

print(integer: p2.x)
print(integer: p2.x*/