import stdlib

class A {
	func a() {
		print(string: "A::a()")
	}

	let A_a: Int = 10

	func foo() {
		print(string: "A::foo()")
		self.a()
		self.joze()
	}
}

class B: A {
	
	let B_b: Int = 33

	override func a() {
		print(string: "B::a()")
	}

	func b() {
		print(string: "B::b()")
	}
}

class C: B {
	override func a() {
		print(string: "C::a()")
	}

	let C_c: Int = 100
}

########################
/*var a: A
let x = 30

if x == 10 {
	a = A()
}
else if x == 20 {
	a = B()
}
else {
	a = C()
}

a.a()

C().foo()
C().b()

print(integer: C().A_a)
print(integer: C().B_b)
print(integer: C().C_c)*/

#######################

/*var object: A = B()

let casted = object as B

if casted != nil {
	casted.b()
}
else {
	print(string: "cast failed")
}*/

#######################

extension A {

	func joze(a: Int) {
		print(string: "extension::A::joze(a:)")
		print(integer: a)
	}

	func joze() {
		print(string: "extension::A::joze()")
	}
}


/*A().foo()
A().joze(a: 10)
A().joze()
B().joze(a: 20)
B().joze()
B().a()*/

#######################

struct Point {
	var x: Int = 0
	var y: Int = 0
}

var p1 = Point()
var p2 = p1

print(integer: p1.x)
print(integer: p1.y)

print(integer: p2.x)
print(integer: p2.y)

p2.y = 20

print(integer: p1.x)
print(integer: p1.y)

print(integer: p2.x)
print(integer: p2.y)


extension Point {
	func test() {
		print(string: "extension::Point::test()")
	}
}


p1.test()

